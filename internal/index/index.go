// Package index provides functionality for generating and managing ADR index files.
package index

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/sventorben/decider/internal/adr"
	"gopkg.in/yaml.v3"
)

const (
	// IndexFilename is the default name for the index file.
	IndexFilename = "index.yaml"
	// IndexHeader is the comment at the top of the generated index file.
	IndexHeader = "# AUTO-GENERATED by decider index - DO NOT EDIT\n"
)

// Entry represents a single ADR in the index.
type Entry struct {
	ADRID      string   `yaml:"adr_id"`
	Title      string   `yaml:"title"`
	Status     string   `yaml:"status"`
	Date       string   `yaml:"date"`
	Tags       []string `yaml:"tags,omitempty"`
	ScopePaths []string `yaml:"scope_paths,omitempty"`
	File       string   `yaml:"file"`
}

// Index represents the complete ADR index.
type Index struct {
	GeneratedAt string  `yaml:"generated_at"`
	ADRCount    int     `yaml:"adr_count"`
	ADRs        []Entry `yaml:"adrs"`
}

// Generate creates an index from a list of ADRs.
func Generate(adrs []*adr.ADR) *Index {
	entries := make([]Entry, len(adrs))
	for i, a := range adrs {
		entries[i] = Entry{
			ADRID:      a.Frontmatter.ADRID,
			Title:      a.Frontmatter.Title,
			Status:     string(a.Frontmatter.Status),
			Date:       a.Frontmatter.Date,
			Tags:       a.Frontmatter.Tags,
			ScopePaths: a.Frontmatter.Scope.Paths,
			File:       a.Filename,
		}
	}

	return &Index{
		GeneratedAt: time.Now().UTC().Format(time.RFC3339),
		ADRCount:    len(adrs),
		ADRs:        entries,
	}
}

// Write serializes the index to a file.
func (idx *Index) Write(filePath string) error {
	data, err := yaml.Marshal(idx)
	if err != nil {
		return fmt.Errorf("marshaling index: %w", err)
	}

	content := IndexHeader + string(data)
	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("writing index file: %w", err)
	}

	return nil
}

// Load reads and parses an index file.
func Load(filePath string) (*Index, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("reading index file: %w", err)
	}

	var idx Index
	if err := yaml.Unmarshal(data, &idx); err != nil {
		return nil, fmt.Errorf("parsing index file: %w", err)
	}

	return &idx, nil
}

// Exists checks if an index file exists.
func Exists(adrDir string) bool {
	_, err := os.Stat(filepath.Join(adrDir, IndexFilename))
	return err == nil
}

// GenerateFromDir loads ADRs from a directory and generates an index.
func GenerateFromDir(adrDir string) (*Index, error) {
	adrs, err := adr.LoadAllADRs(adrDir)
	if err != nil {
		return nil, fmt.Errorf("loading ADRs: %w", err)
	}
	return Generate(adrs), nil
}

// WriteToDir generates and writes an index to the ADR directory.
func WriteToDir(adrDir string) error {
	idx, err := GenerateFromDir(adrDir)
	if err != nil {
		return err
	}
	return idx.Write(filepath.Join(adrDir, IndexFilename))
}

// Check verifies that the index file is up-to-date with the ADRs.
func Check(adrDir string) (bool, error) {
	indexPath := filepath.Join(adrDir, IndexFilename)

	// Load existing index
	existing, err := Load(indexPath)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, fmt.Errorf("loading existing index: %w", err)
	}

	// Generate fresh index
	fresh, err := GenerateFromDir(adrDir)
	if err != nil {
		return false, err
	}

	// Compare (ignoring generated_at timestamp)
	if existing.ADRCount != fresh.ADRCount {
		return false, nil
	}

	if len(existing.ADRs) != len(fresh.ADRs) {
		return false, nil
	}

	for i := range existing.ADRs {
		if !entriesEqual(existing.ADRs[i], fresh.ADRs[i]) {
			return false, nil
		}
	}

	return true, nil
}

func entriesEqual(a, b Entry) bool {
	if a.ADRID != b.ADRID || a.Title != b.Title || a.Status != b.Status ||
		a.Date != b.Date || a.File != b.File {
		return false
	}

	if len(a.Tags) != len(b.Tags) {
		return false
	}
	for i := range a.Tags {
		if a.Tags[i] != b.Tags[i] {
			return false
		}
	}

	if len(a.ScopePaths) != len(b.ScopePaths) {
		return false
	}
	for i := range a.ScopePaths {
		if a.ScopePaths[i] != b.ScopePaths[i] {
			return false
		}
	}

	return true
}
